# 3번째 문제풀이

## DP

### 2. 정수 삼각형

전형적인 DP 문제. 굳이 DP테이블을 만들 필요없었지만 그냥 따로 만들어봤다.
점화식은 `a[i][j] = a[i][j] + max(a[i - 1][j - 1], a[i - 1][j])`

삼각형에서 양 끝은 점화식이 필요없고 그 `a[i - 1][j]` 혹은 `a[i - 1][j - 1]`을 더하면 된다.

이후 마지막 행의 제일 큰 값을 구하면 끝

```python
n = int(input())

triangle = []

for i in range(n):
    tmp = list(map(int, input().split()))
    triangle.append(tmp)

dp = triangle.copy()

for i in range(1, n):
    for j in range(0, i + 1):
        if j != 0 and j != i:
            dp[i][j] += max(dp[i - 1][j - 1], dp[i - 1][j])
        elif j == 0:
            dp[i][j] += dp[i - 1][j]
        elif j == i:
            dp[i][j] += dp[i - 1][j - 1]

print(max(dp[n - 1]))
```

<br>

## 최단 경로

### 1. 플로이드

제목부터 플로이드 워셜 알고리즘을 사용하라고 알려준다.
모든 경로에서의 최단거리이고 출력값도 배열로 나타낸다.

그냥 플로이드를 쓰면 안되고 입력값이 중복이 있기 때문에 입력 받을 때 INF가 아닌 다른 값이 존재한다면 min값을 넣게끔 코드를 추가하고 플로이드 워셜 알고리즘을 그대로 사용하면 됐다.

```python
INF = int(1e9)

n = int(input())
m = int(input())

graph = [[INF] * (n + 1) for i in range(n + 1)]

# 중복이 있어서 최소 값을 입력받기 위해 추가한 코드
for i in range(m):
    a, b, c = map(int, input().split())

    if graph[a][b] != INF:
        graph[a][b] = min(graph[a][b], c)
    else:
        graph[a][b] = c

for a in range(1, n + 1):
    for b in range(1, n + 1):
        if a == b:
            graph[a][b] = 0

for k in range(1, n + 1):
    for a in range(1, n + 1):
        for b in range(1, n + 1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

for a in range(1, n + 1):
    for b in range(1, n + 1):
        print(graph[a][b], end=' ')
    print()
```
