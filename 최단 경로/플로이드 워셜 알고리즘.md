# 플로이드 워셜 알고리즘

다익스트라 알고리즘은 '한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우'에 사용할 수 있는 최단 경로 알고리즘이다.

이번에 설명하는 플로이드 워셜 알고리즘(Floyd-Warshall Algorithm)은 '모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우'에 사용할 수 있는 알고리즘이다.

단계마다 '거쳐 가는 노드'를 기준으로 알고리즘을 수행한다. 매번 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾을 필요가 없다는 점이 다익스트라 알고리즘과 다르다.

노드의 개수가 N개 일 때 알고리즘상으로 N번의 단계를 수행하며, 단계마다 O(N^2)의 연산을 통해 '현재 노드를 거쳐 가는' 모든 경로를 고려한다. 따라서 O(N^3)의 시간복잡도를 가진다.

예를 들어 1번 노드에 대해 확인할 때, 1번 노드를 중간에 거쳐 지나가는 모든 경우를 고려하면 된다.
A -> 1번노드 -> B로 가는 비용을 확인한 후에 최단 거리를 갱신한다.

정확한 점화식은 다음과 같다.

> D(ab) = min(D(ab), D(ak) + D(kb))

즉, 'A에서 B로 가는 최소 비용'과 'A에서 K를 거쳐 B로 가는 비용'을 비교하여 더 작은 값으로 갱신하겠다는 것이다.

```python
INF = int(1e9)

# 노드의 개수 및 간선의 개수를 입력받기
n = int(input())
m = int(input())
# 2차원 리스트(그래프 표현)를 만들고, 모든 값을 무한으로 초기화
graph = [[INF] * (n + 1) for _ in range(n + 1)]
# 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
for a in range(1, n + 1):
    for b in range(1, n + 1):
        if a == b:
            graph[a][b] = 0

# 각 간선에 대한 정보를 입력받아, 그 값으로 초기화
for _ in range(m):
    # A에서 B로 가는 비용은 C라고 설정
    a, b, c = map(int, input().split())
    graph[a][b] = c

# 점화식에 따라 플로이드 워셜 알고리즘을 수행
for k in range(1, n + 1):
    for a in range(1, n + 1):
        for b in range(1, n + 1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

# 수행된 결과를 출력
for a in range(1, n + 1):
    for b in range(1, n + 1):
        # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
        if graph[a][b] == INF:
            print("INFINTY", end=" ")
        # 도달할 수 있는 경우 거리를 출력
        else:
            print(graph[a][b], end=" ")
    print()

```

### 느낀점

문제를 풀 때 알고리즘의 큰 변동없이 노드에 맞춰 그대로 쓰면 값이 나왔다. 그런 문제만 푼 걸 수도 있겠지만 어쨋든 이론은 조금 길어서 어려우나 최소 거리를 구할 때 그대로 쓰면 되기 때문에 편했다.

BFS도 최단거리를 구할 때 썼는데, 유형을 봤을 때 BFS는 직각사각형?에서 써야 좋았고 최단거리 알고리즘은 그래프로 되어있는 유형일 때 쓰면 좋은 것 같다. 아 그리고 가중치가 있을 때 특히 최단거리 알고리즘을 써야한다. 그저 가는 길이 1씩 늘어난다면 BFS를 써도 상관 없을 것 같다.

문제를 풀다보면 유형을 깨닫겠지 싶다.
