# 다이나믹 프로그래밍

메모리 공간을 약간 더 사용하여 연산 속도를 비약적으로 증가시킬 수 있는 방법이다.

대표적인 예시로 피보나치 수열이 있다.
피보나치 수열은 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다. 피보나치 수열은 다음과 같은 형태로 끝없이 이어진다.

> 1 1 2 3 5 8 13 21 34 55 89 ...

수학자들은 점화식을 사용해 수열의 항이 이어지는 형태를 간결하게 표현한다.

> a(n+2) = f(a(n+1), a(n)) = a(n+1) + a(n)

첫 번째 항과 두 번째 항의 값이 모두 1이기 때문에

> a(n) = a(n-1) + a(n-2), a(1) = 1, a(2) = 1

이를 해석하면 다음과 같다.

- n번째 피보나치 수 = (n - 1)번째 피보나치 수 + (n - 2)번째 피보나치 수
- 단, 1번째 피보나치 수 = 1, 2번째 피보나치 수 = 1

프로그래밍에서는 이러한 수열을 **배열**이나 **리스트**로 표현할 수 있다.

수학적 점화식을 프로그래밍으로 표현하려면 재귀 함수를 사용하면 간단하다.

```python
# 피보나치 함수를 재귀 함수로 구현
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))
```

그런데 피보나치 수열의 소스코드를 이렇게 작성하면 n이 커질수록 수행 시간이 기하급수적으로 늘어난다.
빅오 표기법으로 O(2^n)의 지수시간이 소요된다고 한다.
n = 30이면 약 1-억 가량의 연산을 수행해야 한다..

이는 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있다.

---

다이나믹 프로그래밍은 다음 조건을 만족할 때 사용할 수 있다.

1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

피보나치 수열은 이러한 조건을 만족하는 대표 문제이다.
이 문제를 **메모이제이션(Memoization)**기법을 사용해서 해결해보자.
메모이제이션은 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미한다. 메모이제이션은 값을 저장하는 방법이므로 **캐싱(Caching)**이라고도 한다.

한 번 구한 정보를 리스트에 저장하고 재귀적으로 수행하다가 같은 정보가 필요할 때 이미 구한 정답을 그대로 리스트에서 가져오면 된다.

```python
# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수(Fibonacci Function)를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)


def fibo(x):
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]


print(fibo(99))
```

정리하자면 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다.

시간 복잡도는 O(N)이다

또한 이러한 재귀 함수를 이용하여소스코드를 작성하는 방식을 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 **탑다운(Top-Down)방식** 이라고 한다.
반면에 단순히 반복문을 이용하여 작은 문제부터 차근차근 답을 도출하는 방식을 **바텀업(Bottom-Up)방식** 이라고 한다.

```python
# 바텀업 방식(Bottom-up)
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수 반복문으로 구현(바텀업 다이나믹 프로그래밍)
for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```

바텀업에서 사용되는 결과 저장용 리스트는 `DP 테이블`이라고 부르며, `메모이제이션`은 탑다운 방식에 국한되어 사용되는 표현이다.

## 느낀점

결국 DP문제는 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하여 푸는 것이 중요하다. 특정한 문제를 완전탐색으로 풀었을 때 시간이 오래걸린다면 중복 여부를 확인해봐야한다.

또한 책에서 탑다운 형식보다 바텀업 형식을 권장한다고 한다. 왜냐하면 시스템상 재귀 함수의 스택크기가 한정되어 있을 수 있기 때문이다.

또한 문제를 풀면서 느낀 점은 다이나믹 프로그래밍 문제는 **점화식**을 세우는 것이 제일 중요한 것 같다. 주어진 문제가 DP문제인지 확인 한 후, 제일 작은 수 일 때(0이나 1일 때) 값을 설정하고, 큰 문제를 해결할 방법을 점화식으로 찾는다. 그리고 DP테이블을 만들고 점화식에 따라 바텀업방식으로 소스코드를 구현한다.

재귀 함수로 점화식을 구현하는게 쉽지만 재귀함수는 확인하기가 어렵고 한정되어 있으므로 바텀업 방식으로 for문을 이용해 구현해보도록 한다.

1부터 차근차근 종이에 써가면서 점화식이 맞는지 확인해보는 것도 중요한 것 같다.
